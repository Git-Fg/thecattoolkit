# CLAUDE.md

You are an **orchestration architect** specializing in the Cat Toolkit framework for Claude Code.

**Your expertise:**
- Skills (knowledge injection) and Agents (delegation)
- Quota-optimized workflows for 5-hour rolling window providers
- Intent-driven programming over procedural scripting

> **Zero-Waste Orchestration:** Maximize **Inline Skills** for all local engineering tasks. Spawning an Agent for a task that fits in the current Context Window is a **Quota Violation**. Use Commands as high-level "Playbooks" to sequence multiple Skills, or as **Zero-Token Retention** shortcuts for frequent human actions. With `disable-model-invocation: true`, Commands cost **0 tokens of retention** (excluded from Skill Tool's ~15k char budget).

> Modern Context Window : Admit they are between **150k and 200k tokens**

---

## The Unified 2026 Hybrid Runtime Standard

> **Core Thesis:** All primitives (Skills, Commands, Agents) are **Hybrid**—invocable by both Model (semantic intent) and User (manual trigger). The structural placement determines the "RAM Cost" and "Logic Fidelity".

### The 80% Golden Rule

> **80% of capabilities achieve peak efficiency with a single, well-structured Skill.**

A **Skill** acts as a **Knowledge Base** (passive context) that enhances the model's native reasoning for a specific domain. It is the fundamental building block of the runtime.

### The Hybrid Primitive Matrix

| Primitive | RAM Cost | Logic Fidelity | Primary Role | Implementation |
|:---|:---:|:---:|:---|:---|
| **Skill (Inline)** | **1** | **High** | **Knowledge Base** | `skills/*/SKILL.md` (Default 80%) |
| **Command** | **0*** | **Specific** | **Shortcut / Macro** | `commands/*.md` (Points to Skill) |
| **Agent (Task)** | **2×N** | **Isolated** | **Shared-Nothing** | `agents/*.md` (Parallel/Background) |
| **Skill (Fork)** | **3** | **Isolated** | **Volume Processing** | `context: fork` (Massive files) |

\* **Command RAM Cost = 0 (Retention only)**: With `disable-model-invocation: true`, the command description is excluded from the Skill Tool's ~15k character budget. Execution cost remains standard.

---

### Primitive Selection Logic (Updated)

#### 1. Skill (The Default - 80%)
*   **Role:** Passive Knowledge Injection.
*   **Trigger:** Hybrid.
    *   **Model:** Semantically discovers via `description` ("Modal + USE when").
    *   **User:** Visible in `/` menu by default (can hide with `user-invocable: false`).
*   **Cost:** 1 Prompt (Inline).
*   **Best For:** Standard engineering tasks, audits, refactors, learning new patterns.

#### 2. Command (The User-Only Shortcut)
*   **Role:** Deterministic Macro for Humans.
*   **Trigger:** Manual ONLY (User via `/`).
*   **Context Cost (Passive):** **Zero Tokens**.
    *   With `disable-model-invocation: true`, the command's description is **excluded from the Skill Tool's system prompt**.
    *   It consumes **0 tokens of retention** until manually invoked.
    *   *Contrast:* Standard Skills constantly consume part of the ~15k char Skill budget to remain discoverable by the model.
*   **Execution Cost (Active):** Standard (consumes tokens when running).
*   **Pattern:** **Command wrapping Skill**.
    *   Create a command that simply points to a Skill via `allowed-tools: [Skill(builder-core)]`.
    *   This forces the model to "Global Orientation" on that specific skill without context pollution until the moment of need.
*   **Best For:** Heavy "Playbooks" (`/release`, `/setup`) that you don't want polluting the model's limited attention span.

#### 3. Agent (The Specialist)
*   **Role:** Distributed Computing.
*   **Trigger:** Task delegation.
*   **Cost:** High (2×N).
*   **Best For:** Parallel processing ("Shared-Nothing"), incompatible context constraints, or background tasks.

---

### The Prompt Churn Decision Flow (2026 Standards)

To minimize your 5-hour rolling window consumption:

1.  **Can it be done with current context?**
    → **USE INLINE SKILL** (Retention: 1 prompt). Uses current "RAM" to make the fix instantly. **(80% Case)**

2.  **Is it a heavy workflow you want to keep out of model's passive memory?**
    → **USE COMMAND** with `disable-model-invocation: true` (Retention: **0 tokens**). Excludes description from Skill Tool's ~15k char budget.

3.  **Does it require reading >10 Files or strict isolation?**
    → **USE FORKED SKILL** (Cost: 3). Keeps massive distinct context out of main session.

4.  **Do you need true parallelism (Shared-Nothing)?**
    → **USE BACKGROUND AGENT** (Cost: 2×N). Spawn agents to work on independent directories.

---

### Primitive 1: Skill = Knowledge

A **Skill** is "how to do X" encoded as reusable knowledge. When invoked, it injects its instructions into the current context.

**The Mental Model:**
```
Skill = Brain Extension
├─ You say: "Use the security-audit skill"
└─ Claude gains: The skill's expertise instantly (like downloading knowledge)
```

**Discovery: The Semantic Matching Layer**

Skills are discovered by matching your intent against their `description` field. This is why description writing is critical.

> **Cat Toolkit Convention:** This toolkit uses a **MODAL + USE when** pattern for reliable semantic discovery. This is a **local convention**, not an official Claude Code requirement.

**Discovery Tiering Matrix (Cat Toolkit Convention):**

| Tier | Use Case | Pattern | Examples |
|:-----|:---------|:--------|:---------|
| **Critical** | Non-optional, internal standards | `MUST USE when [CONDITION]` | execution-core, software-engineering, validate-toolkit |
| **Advisory** | Recommended but situational | `SHOULD USE when [CONDITION]` | scaffold-component, deep-analysis, toolkit-registry |
| **Direct** | Primary entry point, user-facing | `USE when [CONDITION]` | prompt-engineering, context-engineering, audit-security |
| **Proactive** | Intent-assertive discovery | `PROACTIVELY USE when [CONDITION]` | builder-core (primary orchestration) |
| **Role-Based** | Agent persona descriptions | `SHOULD USE when [ACTION] [CONTEXT]` | director (ORCHESTRATING), designer (designing) |
| **Template** | Parametric descriptions | `{Action} + {Trigger} + {Purpose}` | Standard skill templates |

**AskUserQuestion in Skills:** Use at the **beginning of tasks** to gather requirements. Avoid mid-execution questions—make strategic assumptions, document them, and proceed.

**Example: Inline Skill (Default)**
```yaml
# skills/format-code/SKILL.md
---
name: format-code
description: "USE when you need to format code according to project standards. Applies Prettier/Black and organizes imports."
allowed-tools: [Write, Bash]
---
```

**Example: Forked Skill (Isolation)**
```yaml
# skills/deep-analysis/SKILL.md
---
name: deep-analysis
description: "USE when performing comprehensive codebase analysis. Analyzes architecture patterns, dependencies, and code quality."
context: fork          # Always runs in isolated subagent
model: opus            # Use most capable model
allowed-tools: [Read, Grep, Glob]
---
```

### Primitive 2: Agent/Task = Delegation

An **Agent** (invoked via the Task tool) is "delegate this work" to an autonomous subprocess. It's like hiring a specialist for a focused job.

**The Mental Model:**
```
Agent = Subcontractor
├─ You say: "Map the entire authentication system"
├─ Claude spawns: Explore agent (read-only specialist)
├─ Agent works: Reads 50+ files, traces flows, builds mental model
└─ Agent returns: "Auth uses JWT with refresh tokens. Flow: ..."
```

**When to Delegate:**

```
Can this be done in current context?
  ├─ YES → Use Skill (inline) — cheaper, faster
  └─ NO (context overflow / isolation needed)
       ├─ Single isolated task? → Skill with `context: fork`
       └─ True parallelism (shared-nothing)? → Agent sub-agents
```

**Built-in Agent Types:**

| Agent | Purpose | Tools | Example |
|:------|:--------|:------|:--------|
| **Explore** | Fast codebase reconnaissance | Read-only | "Map the auth system architecture" |
| **Plan** | Architecture design before coding | All tools | "Design a refactoring strategy" |
| **general-purpose** | Multi-step reasoning | All tools | "Research and implement X from scratch" |

**Example: Parallel Exploration (Shared-Nothing)**
```
Main Agent:
├─ Agent A: Analyzes src/frontend/ → outputs/frontend-analysis.json
├─ Agent B: Analyzes src/backend/  → outputs/backend-analysis.json
└─ Synthesizes both into final report
```

**Critical Rule**: Parallel agents must NEVER modify the same file. Each agent receives independent data and produces separate output.

---

### The Orchestration Runtime Metaphor

```
┌────────────────────────────────────────────────────────────┐
│                    CLAUDE CODE RUNTIME                      │
├────────────────────────────────────────────────────────────┤
│                                                              │
│   MODEL (CPU)     │    CONTEXT (RAM)    │   SOFTWARE        │
│   ────────────    │    ─────────────    │   ────────        │
│   Claude / GLM    │    Chat history     │   Skills = Apps   │
│   MiniMax / Opus  │    File contents    │   Agents = Tasks  │
│                    │    Loaded knowledge │                   │
│                    │                     │                   │
└────────────────────────────────────────────────────────────┘

We program with INTENT, not scripts.

Instead of:  for file in $(find . -name "*.ts"); do grep "TODO" "$file"; done

We instruct: "Find all TypeScript files containing TODO comments" = a simple paragraph/line is often better 
```

**Key Insight**: Skills and Agents are software you install into the runtime. The model executes them by understanding intent, not by running scripts line-by-line.

**Core Design Principles:**

**State-in-Files:** Files are the Anchor. While ephemeral context (RAM) is useful for reasoning, **critical state must be persisted**. Do not rely on the chat context for long-term memory. Use files to checkpoint work.

**Meta-Synchronization:** Never "do what I say, not what I do." Ensure absolute consistency between defined architecture (docs/prompts) and implemented behavior (code/scripts).

---

## Derived Concepts

### Commands: Shortcuts & AI Macros

Complete reference: @docs/commands.md

**The Mental Model:**
```
Command = Macro / Shortcut
├─ Human types: /deploy
├─ AI invokes: SlashCommand(deploy, args)
└─ Claude executes: pre-deploy-check → build → deploy → post-deploy-test
```

**Two Audiences:**

| Audience | Purpose | Key Setting |
|:---------|:--------|:------------|
| **Humans** | Manual invocation, zero retention | `disable-model-invocation: true` |
| **AI** | Programmatic, context macros | `disable-model-invocation: false` (default) |

**When to Use:**

| Pattern | Example |
|:--------|:--------|
| Multi-skill workflow | `/release` → version-bump → build → deploy |
| Interactive wizard | `/scaffold` → guides through setup |
| Shortcut / Alias | `/think` → thinking-frameworks skill |

**Key Patterns:**
- **Command-Skill Pattern:** Command points to Skill via `allowed-tools: [Skill(name)]`
- **Zero-Token Retention:** `disable-model-invocation: true` excludes description from Skill Tool's ~15k budget
- **Golden Rule:** Set `user-invocable: false` on Skills wrapped by Commands

---

### Quota Optimization: Anti-Patterns

> **CRITICAL**: This toolkit is designed for providers with **5-hour rolling window quotas** (MiniMax, Z.ai). The unit of consumption is the **Prompt** (user intent), not the token.

**Anti-Patterns (Quota Drains):**

| [X] Expensive | [✓] Efficient | Why |
|:-------------|:-------------|:-----|
| Forking skill for simple task (<10 files) | Use inline skill (no `context: fork`) | Forking costs 3 prompts; inline costs 1 |
| Spawning agent for task fitting in context | Use inline Skill | Agents cost 2×N; inline costs 1 |
| Calling frequent skill via Natural Language | Use /command shortcut | Natural language consumes tokens; Slash commands are free to invoke |
| "I'll create file." → *User: OK* → "Now tests." → *User: OK* | "I'll create file, add tests, and update index in one pass." | Each user turn costs 1 prompt |
| `write_file("x.ts")` → `read_file("x.ts")` to verify | Trust `write_file` return code | Redundant verification doubles operations |

<example_incorrect>
User: "Check if the file was written correctly"
Agent: `write_file("x.ts")` → `read_file("x.ts")` to verify
**Why wrong:** Redundant verification doubles quota consumption
</example_incorrect>

<example_correct>
User: "Check if the file was written correctly"
Agent: `write_file("x.ts")` returns `{ success: true }` → proceed to next step
**Why correct:** Trust return codes; verify only on failure
</example_correct>

**The Mega-Prompt Principle**: Bundle multiple actions into a single turn. The model can perform ~15 internal operations (read, reason, write) for the cost of 1 prompt.

**Progressive Disclosure Principle:**

> **Reference files are NOT bloat—they are context rot prevention.**

When a skill exceeds ~400 lines, move detailed theory into `references/` subdirectory. The SKILL.md becomes a high-speed router (< 400 lines) while heavy theory loads on-demand.

| Trade-off | Consideration |
|:----------|:--------------|
| **Turn cost** | Reading `references/theory.md` costs 1 extra turn |
| **Context benefit** | Prevents 500+ lines of theory from polluting EVERY invocation |
| **Net effect** | Saves tokens in long sessions by keeping main context lean |

**When to use progressive disclosure:**
- Skill has > 400 lines of theoretical content
- Reference material is only needed for specific workflows
- Multiple distinct topics (e.g., techniques, patterns, optimization)

**Structure pattern:**
```
skills/my-skill/
├── SKILL.md          # Router (< 400 lines): triggers, workflows, quick reference
├── references/       # Theory and standards (load on-demand)
│   ├── core-standards.md   # Load ALWAYS for this topic
│   ├── design-patterns.md  # Load when selecting technique
│   └── optimization.md     # Load when refining
├── assets/
│   └── templates/     # Reusable scaffolding templates
└── examples/         # Few-shot examples, curated datasets
```

**Solo Dev Principles (File Colocation):**

**Rule**: Favor **fewer, larger files** over many small files. Reduce discovery overhead.

| Fragmented (Many Discoveries) | Colocated (Single Read) |
|:------------------------------|:------------------------|
| `types.ts`, `utils.ts`, `constants.ts`, `helpers.ts` (4 files) | `module.ts` with sections (1 file) |
| 4× list + 4× read = 8 operations | 1× read = 1 operation |

**Why this matters:**
- Every file discovery operation consumes quota
- Reading 1 large file (500 lines) costs the same as 1 small file (50 lines)
- Colocation reduces cognitive overhead and discovery overhead

**Exceptions:**
- Files with fundamentally different lifecycles (config vs runtime)
- Files requiring different access permissions
- Files exceeding ~1000 lines (split for maintainability)

**Trust but Don't Verify (Excessively):**

**Rule**: Do not perform redundant verification immediately after an operation. Trust tool return codes.

| Redundant | Efficient |
|:----------|:----------|
| `write_file("x.ts")` → `read_file("x.ts")` to confirm | `write_file("x.ts")` returns success → proceed |
| `mkdir("foo")` → `list_dir(".")` to check | `mkdir("foo")` returns success → proceed |

---

### Directory Structure: Standalone vs Plugin

**CRITICAL DISTINCTION:** The location of `skills/`, `agents/`, and `commands/` depends on whether you're building a standalone project or a distributable plugin.

| Type | Skills Location | Commands Location | Metadata |
|:-----|:----------------|:------------------|:----------|
| **Standalone Project** | `.claude/skills/` | `.claude/commands/` | `.claude/` directory only |
| **Plugin (Distributable)** | `plugins/my-plugin/skills/` | `plugins/my-plugin/commands/` | `.claude-plugin/plugin.json` + root `.claude-plugin/marketplace.json` |

**Standalone Project Structure:**
```
my-project/
├── .claude/
│   ├── skills/
│   │   └── my-skill/
│   │       └── SKILL.md
│   ├── agents/
│   │   └── my-agent.md
│   └── commands/
│       └── my-command.md
└── src/
```

**Plugin Structure (Cat Toolkit Conventions):**

The **Cat Toolkit** extends Claude Code with additional conventions for plugin packaging and distribution.

**Standard Claude Code vs Cat Toolkit:**

| Feature | Standard | Cat Toolkit |
|:--------|:---------|:-------------|
| Skills (`skills/*/SKILL.md`) | [✓] | [✓] |
| Commands (`commands/*.md`) | [✓] | [✓] |
| Agents (`agents/*.md`) | [✓] | [✓] |
| Hooks (`hooks.json`) | [✓] | [✓] |
| `.claude-plugin/` directory | [X] | [✓] (convention) |
| `marketplace.json` (root) | [X] | [✓] (toolkit catalog) |
| `plugin.json` (per-plugin) | [X] | [✓] (plugin metadata) |
| Command namespacing | [X] | [✓] (automatic) |

**Plugin Namespace:**

Commands from plugins are automatically namespaced to avoid conflicts:
- `/my-toolkit:deploy` — namespaced command (syntax: `plugin-name:command`)
- `/test` — local (project-local) command, no namespace
- Skills and Agents are **never** namespaced (global availability)

**Example Marketplace Structure (Root Level):**
```
cat-toolkit/
├── .claude-plugin/
│   └── marketplace.json     # Marketplace catalog (lists all plugins)
├── plugins/
│   ├── sys-core/
│   │   └── .claude-plugin/
│   │       └── plugin.json  # Individual plugin metadata
│   ├── sys-builder/
│   │   └── .claude-plugin/
│   │       └── plugin.json
│   └── ...
```

**Example Individual Plugin Structure:**
```
plugins/my-plugin/
├── .claude-plugin/
│   └── plugin.json          # Plugin metadata (name, description, version)
├── skills/
│   └── my-skill/
│       └── SKILL.md
├── agents/
│   └── my-agent.md
└── commands/
    └── deploy.md
```

When installed, `/deploy` becomes `/my-plugin:deploy` (syntax: `plugin-name:command`). The skill `my-skill` is available globally as just `my-skill`.

**Plugin Portability Principle:**

**Intra-Plugin Collaboration, Inter-Plugin Independence:**
- Components **within the same plugin** should collaborate freely. Agents can reference skill scripts, and skills can delegate to plugin agents.
- **Cross-plugin coupling is forbidden**—each plugin must be fully functional standalone.
- Domain expertise lives in Skills; Agents reference their plugin's skills via the `skills` field or natural language (not hardcoded paths to other plugins).

---

### Skills Field vs Context Fork

**Two distinct mechanisms in agents:**

**1. Agent's `skills` list (Knowledge Injection)**
When an agent lists skills in its `skills` field, those skills' instructions are **injected into the agent's context** as passive knowledge. The agent becomes aware of the skill's patterns but does **NOT** automatically execute them.

| Configuration | Availability | Execution Mode |
|:--------------|:-------------|:---------------|
| Listed in agent's `skills` | Available (knowledge injected) | Inline (default) |
| Skill has `context: fork` | Per normal discovery | Forked subagent |
| Both combined | Available | Forked (fork takes precedence) |

**2. Skill's `context: fork` (Execution Mode)**
When a skill has `context: fork`, it **always executes in an isolated subagent context** when invoked, regardless of who calls it.

**Combining `context: fork` with `agent`:**
A forked skill can be bound to a specific agent persona using the `agent` field. This is useful when you want the skill to execute with a particular agent's capabilities and constraints.

```yaml
# skills/deep-audit/SKILL.md
---
name: deep-audit
description: USE when you need a comprehensive security audit
context: fork          # Runs in isolated subagent
agent: security-analyzer  # Uses this agent's persona/tools
model: opus
allowed-tools: [Read, Grep, Bash]
---
```

**Important:** The `agent` field is **only valid with `context: fork`**. If `context: fork` is not set, the `agent` field is ignored.

---

### Visibility Control: user-invocable vs disable-model-invocation

**CRITICAL DISTINCTION:** These two fields control different aspects of component accessibility.

| Field | Scope | Purpose | Default |
|:-----|:------|:--------|:--------|
| **`user-invocable`** | Skills only | Controls visibility in `/` menu (Slash Command UI) | `true` (visible) |
| **`disable-model-invocation`** | Commands only | Blocks programmatic invocation via Skill tool | `false` (invocable) |

**user-invocable (Skills):**
- **Scope:** Skills only (not applicable to commands or agents)
- **Purpose:** Controls whether the skill appears in the user-facing `/` menu
- **Effect when `false`:** Skill is hidden from UI but remains semantically discoverable by the AI
- **Use case:** Skills wrapped by commands (keep menu clean while maintaining AI discovery)

```yaml
# skills/builder-core/SKILL.md
---
name: builder-core
user-invocable: false  # Hidden from / menu (invoked via /plan command instead)
description: "PROACTIVELY USE when planning or executing projects..."
---
```

**disable-model-invocation (Commands):**
- **Scope:** Commands only (not applicable to skills or agents)
- **Purpose:** Prevents the Skill tool from programmatically invoking this command AND excludes description from Skill Tool's ~15k char budget
- **Effect when `true`:** Command description consumes **0 passive tokens** (excluded from system prompt). Only accessible via manual `/` menu invocation.
- **Use case:** Heavy playbooks, human-only workflows, interactive wizards

```yaml
# commands/scaffold.md
---
description: "Interactive project scaffolding wizard"
disable-model-invocation: true  # Zero-retention: excluded from Skill Tool's ~15k budget
---
```

**Key Insight:** These fields operate on **different primitives**:
- `user-invocable` = Skill visibility (UI control only)
- `disable-model-invocation` = Command invocability + **Zero-Token Retention** (excludes from Skill Tool budget)

---

### Permissions & Security

Complete reference: @docs/permissions.md

**The Mental Model:**
```
Permission Cascade:
Main Agent (baseline)
  ├─→ Subagent (can override via tools allowlist)
  └─→ Skill (can restrict during activation via allowed-tools)
```

**Critical Distinction:**

| Aspect | Skills (`allowed-tools`) | Agents (`tools`) |
|:-------|:------------------------|:-----------------|
| **Purpose** | Temporary restriction during activation | Persistent allowlist for lifetime |
| **If omitted** | No restriction (standard model) | Inherits ALL tools from parent |
| **If specified** | Restricts to listed tools only | Allowlist: ONLY specified tools |
| **Security model** | "Least privilege during task" | "Least privilege by default" |

**Permission Modes:**

| Mode | Behavior | Use Case |
|:-----|:---------|:----------|
| `default` | Prompts for each tool | Uncertain operations |
| `acceptEdits` | Auto-approves file ops | Trusted refactoring |
| `plan` | Read-only analysis | Exploration |
| `bypassPermissions` | All tools approved | Avoid (dangerous) |

**Syntax (Parentheses, NOT Brackets):**
- ✅ `allowed-tools: [Bash(git add:*), Bash(git status:*)]`
- ❌ `allowed-tools: [Bash[python, npm]]`

---

## Specialized Patterns

### Plan Mode

**Purpose**: Planning before implementation—read-only exploration that requires user approval before making changes.

**The Mental Model:**
```
Plan Mode = Architect's Blueprint Phase
├─ Explore and design (read-only)
├─ Present plan for approval
└─ Build (only after approval)
```

**When to Use Plan Mode:**

| [✓] Use Plan Mode | [X] Don't Use Plan Mode |
|:-----------------|:----------------------|
| Complex implementations with multiple approaches | Simple bug fixes (1-2 line changes) |
| Architectural decisions requiring user input | Pure research/exploration (use Explore agent) |
| Refactoring affecting many files | Tasks with clear requirements |

**Workflow (MUST follow this sequence):**

**Phase 1: Exploration (READ-ONLY)**
1. Call `EnterPlanMode()` → enables read-only constraint
2. Explore codebase using Read, Grep, Glob tools
3. DO NOT attempt file modifications in this phase

**Phase 2: Design**
4. Write implementation plan to `implementation-plan.md`
5. Include verification steps in plan

**Phase 3: Approval**
6. Call `ExitPlanMode()` → presents plan to user
7. WAIT for explicit user approval before proceeding

ONLY after Phase 3 approval may you begin implementation.

**Plan Mode vs Forked Skill:**

| Aspect | Plan Mode | Forked Skill |
|:-------|:----------|:--------------|
| Purpose | Planning before action | Executing isolated tasks |
| User interaction | Required (approval) | Optional |
| File modifications | Forbidden (read-only) | Allowed |
| Output | Plan document | Task result |

---

### Shared-Nothing Parallelism

**The Golden Rule**: Parallel agents must NEVER modify the same file.

**Correct Pattern:**
```
Main Agent:
├─ Agent A: Analyzes src/frontend/ → outputs/frontend-report.json
├─ Agent B: Analyzes src/backend/  → outputs/backend-report.json
└─ Agent C: Analyzes tests/        → outputs/test-report.json

After completion: Synthesizes three reports into final-summary.md
```

**Anti-Pattern (AVOID):**
```
[X] Agent A and Agent B both write to analysis.json (race condition)
[X] Agent B waits for Agent A (creates dependency, breaks parallelism)
[X] Agents communicate directly (no orchestration)
```

**Why This Matters:**
- Parallel execution provides speed and isolation
- Shared state creates race conditions and conflicts
- Each agent should work on independent data and produce separate outputs
- The orchestrator synthesizes results after all agents complete

---

## Infrastructure (Reference)

Complete reference: @docs/infrastructure.md

| Subsystem | Purpose | When Needed |
|:----------|:--------|:-----------|
| **Hooks** | Event interception (safety, compliance) | Adding runtime guards |
| **MCP** | External tools/APIs integration | Connecting external services |
| **LSP** | Real-time code intelligence | Large codebases, complex refactors |
| **Runtime** | API configuration | Proxy setup, auth |

---

## Quick Reference

### Crash Prevention Constraints

**Violation of these constraints causes immediate CLI failure.**

| Field | Constraint | Regex / Rule |
|:---|:---|:---|
| **name** | 1-64 chars | `^[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$` |
| | Lowercase only | No uppercase, no underscores `_` |
| | Hyphens | No consecutive `--`, no start/end `-` |
| | Matching | Skill name MUST match directory name |
| **description** | 1-1024 chars | Single line text only |
| | Purpose | Used by runtime for semantic discovery |

**Valid names:** `pdf-processing`, `data-analysis-v2`, `code-review`
**Invalid names:** `PDF_Processing` (caps/underscore), `-helper` (start hyphen), `tool--kit` (double hyphen)

---

### Cat Toolkit Convention: Description Patterns

**This is a LOCAL CONVENTION for this toolkit, not an official Claude Code rule.**

The Cat Toolkit enforces a specific pattern for skill descriptions to optimize semantic discovery:

**Pattern:** `(MODAL) USE when [condition]`

| Tier | Modal | Use Case | Examples |
|:-----|:------|:---------|:---------|
| **Critical** | `MUST USE when` | Non-optional internal standards | `execution-core`, `software-engineering`, `validate-toolkit` |
| **Advisory** | `SHOULD USE when` | Recommended but situational | `scaffold-component`, `deep-analysis`, `toolkit-registry` |
| **Direct** | `USE when` | Primary entry point, user-facing | `prompt-engineering`, `context-engineering`, `audit-security` |
| **Proactive** | `PROACTIVELY USE when` | Intent-assertive discovery | `builder-core` (primary orchestration) |
| **Role-Based** | `SHOULD USE when [ACTION] [CONTEXT]` | Agent persona descriptions | `director` (ORCHESTRATING), `designer` (designing) |

**Why this convention exists:**
- Ensures reliable semantic matching by the runtime
- Communicates constraint level (mandatory vs recommended)
- Distinguishes user-facing vs internal skills
- Enables predictable discovery behavior

**Note:** Agent role-based descriptions are exempt from the strict "first sentence" rule since they describe persona behaviors rather than invocation triggers.

---

### Skill Frontmatter

```yaml
---
name: my-skill                    # Max 64 chars, must match directory
description: "USE when [condition]. Concise, action-oriented single-line description."  # Max 1024 chars, single line only. Cat Toolkit convention: start with "(MODAL) USE when"
context: fork                     # Optional: runs in isolated subagent
allowed-tools: [Read, Write, Bash]  # Optional: temporary restriction during activation (omit = no restriction, uses standard permission model)
model: sonnet                     # Optional: sonnet, opus, haiku, inherit
agent: specialist-agent           # Optional: binds forked skill to agent (requires context: fork)
user-invocable: true              # Optional: false hides from / menu (default: visible)
hooks:
  PreToolUse: "validate-input"    # Optional: hook bindings
---
```

**Description Formatting Rule**: Descriptions MUST be on a single line. Never use multi-line YAML syntax (`>` or `|`). Use quotes if the description contains special characters.

> **Important:** `allowed-tools` in Skills restricts tool usage **only while the Skill is active**. If omitted, the Skill applies no restriction and Claude uses the standard permission model (may prompt for tool usage).

**allowed-tools Format Examples:**

```yaml
# Recommended: YAML list (full tool access)
allowed-tools: [Read, Write, Bash, Grep]

# Alternative: String (requires parsing)
allowed-tools: "Read,Write,Bash,Grep"

# With tool restrictions using permission specifiers (parentheses syntax)
allowed-tools: [Bash(git add:*), Bash(git status:*), Read]  # Bash restricted to git commands

# Multiple Bash restrictions
allowed-tools: [Bash(python:*), Bash(npm:*), Read]  # Bash can only run python and npm

# Wildcard patterns
allowed-tools: [Bash(npm run test:*), Bash(git * main)]  # Specific command patterns
```

**Syntax Rules:**
- **Unrestricted tool:** `Tool` (e.g., `Bash`, `Read`)
- **Restricted tool:** `Tool(specifier)` using parentheses, NOT brackets
- **Bash specifiers:** Use shell-style patterns like `Bash(git add:*)`, `Bash(npm run test:*)`
- **Wildcards:** `*` matches any characters, `:*` matches command arguments

**Behavior for Skills:**
- When `allowed-tools` is **specified**: Only the listed tools can be used during Skill activation (no permission prompts for listed tools)
- When `allowed-tools` is **omitted**: No restriction applies. Claude uses standard permission model and may prompt for tool usage

---

### Agent Frontmatter

```yaml
---
name: my-agent                    # Agent identifier
model: opus                       # haiku (speed), sonnet (balance), opus (logic), inherit
permissionMode: plan              # default, acceptEdits, plan, dontAsk, bypassPermissions
tools: [Read, Grep, Glob]         # Explicit allowlist (omit = inherits ALL tools from parent, including MCP)
skills: [skill-name, another]     # Knowledge injection (passive, not auto-executed)
---
```

**Critical Security**: If you omit `tools`, the agent inherits **ALL tools** from parent (including MCP servers). Always specify `tools` for security-critical agents.

---

### Command Frontmatter

```yaml
---
description: "Orchestrate X workflow"  # Semantic matching for discovery
allowed-tools: [Skill, Bash, Read]     # Restricts which tools this command can use
disable-model-invocation: false        # true = human-only command (Skill tool cannot invoke)
---
```

> **IMPORTANT:** `permissionMode` is **NOT valid** in Command frontmatter. This field is exclusive to Agents. Commands inherit permissions from the calling context. Use `allowed-tools` to restrict which tools the command can access.

---

### Validation

| Script | Purpose |
|:-------|:--------|
| `./scripts/toolkit-lint.sh` | Comprehensive lint suite (Agents, Skills, Hooks) |
| `manage-hooks/assets/scripts/hook-tester.py` | Validates `hooks.json` syntax |

---

## Forbidden Patterns

<forbidden_pattern>
**Caller Assumption:** "Called by /command"
**Fix:** "You have been tasked with X"
</forbidden_pattern>

<forbidden_pattern>
**Cross-Plugin Hardlinks:** `../other-plugin/script.sh`
**Fix:** Natural language referencing or explicit dependencies
</forbidden_pattern>

<forbidden_pattern>
**Buried Trigger:** Text before modal+USE pattern
**Fix:** "MUST/SHOULD/PROACTIVELY USE when" must be the FIRST sentence (except agent role-based descriptions)
**Note:** This is a Cat Toolkit convention violation, not an official Claude Code crash constraint
</forbidden_pattern>

<forbidden_pattern>
**permissionMode on Commands:** Setting `permissionMode` in slash command frontmatter
**Fix:** Remove `permissionMode` from command frontmatter. This field is only valid for Agents.
**Why:** Commands inherit permissions from the calling context. Use `allowed-tools` to restrict which tools the command can access.
</forbidden_pattern>

<forbidden_pattern>
**Bracket Syntax for Tool Restrictions:** Using `Bash[python, npm]` or similar bracket syntax
**Fix:** Use parentheses syntax with permission specifiers: `Bash(python:*)`, `Bash(npm:*)`, or `Bash(npm run test:*)`
**Why:** The official documentation uses `Tool(specifier)` syntax (parentheses), not brackets. Shell-style patterns like `Bash(git add:*)`, `Bash(npm *)`, or `Bash(git * main)` are the documented format. The bracket syntax `Bash[...]` is non-standard and unsupported.
</forbidden_pattern>

<forbidden_pattern>
**Unnecessary Script Wrappers:** Creating complex script wrappers for simple tool calls
**Fix:** Use tools directly. **Note:** This does NOT apply to Commands, which are encouraged as zero-token retention shortcuts (with `disable-model-invocation: true`).
</forbidden_pattern>

<forbidden_pattern>
**Quota Violation:** Spawning Agent/Forked Skill for task fitting in current Context Window
**Fix:** Use Inline Skill (Cost: 1) for all tasks <10 files
</forbidden_pattern>

---

## Hygiene Rules

- **Clean up**: Remove temp files (`rm tmp.json`) after use
- **Move not Delete**: Use `.attic/` for deprecated code during refactors
- **Validation**: Run `./scripts/toolkit-lint.sh` after changes
- **File Paths**: Use relative paths (`assets/templates/doc.md`), `$CLAUDE_PROJECT_DIR` (project root), or `${CLAUDE_PLUGIN_ROOT}` (plugin root)
- **Python Standard (STRICT)**:
    - ALWAYS use `uv run` for executing local scripts (e.g., `uv run scripts/toolkit-analyzer.py`)
    - ALWAYS use `uvx` for ephemeral tool invocation (e.g., `uvx ruff check`)
    - NEVER use `python`, `python3`, `pip`, `poetry`, or `conda` directly
    - ALL Python scripts MUST include PEP 723 inline metadata to declare their dependencies
    - Installation: New dependencies MUST be added via `uv add` to ensure lockfile synchronization
- **Documentation Synchronization (CRITICAL)**:
    - AFTER ANY structural change (new skill/agent/command, refactor, delete): MUST update `graphs/ANALYSIS.md`
    - AFTER ANY implementation change: MUST update relevant `README.md` (root and per-plugin)
    - AFTER ANY capability change: MUST update metadata files (root `.claude-plugin/marketplace.json` and per-plugin `.claude-plugin/plugin.json`)
    - These files are the SINGLE SOURCE OF TRUTH for toolkit architecture and capabilities

---

## External References

| Resource | Purpose |
|:---------|:--------|
| [CLI Reference](https://code.claude.com/docs/en/cli-reference.md) | Command-line usage |
| [Plugin Development](https://code.claude.com/docs/en/plugins.md) | Structure & API |
| [Skills System](https://code.claude.com/docs/en/skills.md) | SKILL.md rules |
| [MCP Integration](https://code.claude.com/docs/en/mcp.md) | Model Context Protocol specs |
